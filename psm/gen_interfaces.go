package psm

import (
	"context"
	"fmt"
	"time"

	"github.com/pentops/j5/gen/j5/state/v1/psm_j5pb"
	"github.com/pentops/o5-messaging/o5msg"
	"github.com/pentops/sqrlx.go/sqrlx"
	"google.golang.org/protobuf/proto"
)

/*
# Generic Type Parameter Sets

Two sets of generic type sets exist:

`K S ST SD E IE`
`K S ST SD E IE SE`

Both share the same types, as follows, and defined below

### `K IKeyset`
### `S IState[K, ST, SD]`
### `ST IStatusEnum`
### `SD IStateData`
### `SD IStateData,
E IEvent[K, S, ST, SD, IE]`
### `IE IInnerEvent`
### `SE IInnerEvent`

The Specific single typed event *struct* which is the specific event for the transition.
SE implements the same interface of IE.
e.g. *testpb.FooPSMEvent_Created, the concrete proto message which implements testpb.FooPSMEvent


The state machine deals with the first shorter chain, as it deals with all events.
Transitions deal with a single specific event type, so have the extra SE parameter.

K, S, ST, E, and IE are set to one single type for the entire state machine
SE is set to a single type for each transition.
*/

// IGenericProtoMessage is the base extensions shared by all message entities in the PSM generated code
type IPSMMessage interface {
	proto.Message
	PSMIsSet() bool
}

// IStatusEnum is enum representing the named state of the entity.
// e.g. *testpb.FooStatus (int32)
type IStatusEnum interface {
	~int32
	ShortString() string
	String() string
}

type IKeyset interface {
	IPSMMessage
	PSMFullName() string
	PSMKeyValues() (map[string]string, error) // map of column_name to UUID string
}

// IState[K, ST, SD]is the main State Entity e.g. *testpb.FooState
type IState[K IKeyset, ST IStatusEnum, SD IStateData] interface {
	IPSMMessage
	GetStatus() ST
	SetStatus(ST)
	PSMMetadata() *psm_j5pb.StateMetadata
	PSMKeys() K
	SetPSMKeys(K)
	PSMData() SD
}

// IStateData is the Data Entity e.g. *testpb.FooData
type IStateData interface {
	IPSMMessage
}

// IEvent is the Event Wrapper, the top level which has metadata, foreign keys to the state, and the event itself.
// e.g. *testpb.FooEvent, the concrete proto message
type IEvent[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	Inner any,
] interface {
	proto.Message
	UnwrapPSMEvent() Inner
	SetPSMEvent(Inner) error
	PSMKeys() K
	SetPSMKeys(K)
	PSMMetadata() *psm_j5pb.EventMetadata
	PSMIsSet() bool
}

// IInnerEvent is the typed event *interface* which is the set of all possible events for the state machine
// e.g. testpb.FooPSMEvent interface - this is generated by the protoc plugin in _psm.pb.go
// It is set at compile time specifically to the interface type.
type IInnerEvent interface {
	IPSMMessage
	PSMEventKey() string
}

// HookBaton is sent with each logic transition hook to collect chain events and
// side effects
type HookBaton[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
] interface {
	SideEffect(o5msg.Message)
	DelayedSideEffect(o5msg.Message, time.Duration)
	ChainEvent(IE)
	FullCause() E
	AsCause() *psm_j5pb.Cause
}

type Publisher interface {
	Publish(o5msg.Message)
}

// TransitionMutation runs at the start of a transition to merge the event
// information into the state data object. The state object is mutable in this
// context.
type TransitionMutation[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
	SE IInnerEvent,
] func(SD, SE) error

func (f TransitionMutation[K, S, ST, SD, E, IE, SE]) runMutation(state S, event E) error {
	asType, ok := any(event.UnwrapPSMEvent()).(SE)
	if !ok {
		name := event.ProtoReflect().Descriptor().FullName()
		return fmt.Errorf("unexpected event type in transition: %s [IE] does not match [SE] (%T)", name, new(SE))
	}

	return f(state.PSMData(), asType)
}

func (f TransitionMutation[K, S, ST, SD, E, IE, SE]) eventType() string {
	return (*new(SE)).PSMEventKey()
}

// TransitionHook Executes after the mutations. This hook has access to the
// transaction and can trigger side effects, including chained events, which are additional
// events processed by the state machine.
type TransitionHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
	SE IInnerEvent,
] struct {
	Callback    func(context.Context, sqrlx.Transaction, HookBaton[K, S, ST, SD, E, IE], S, E) error
	RunOnFollow bool // If true, this hook runs on follow-up events, not just the initial transition.
}

func (hook TransitionHook[K, S, ST, SD, E, IE, SE]) runTransition(ctx context.Context, tx sqrlx.Transaction, baton HookBaton[K, S, ST, SD, E, IE], state S, event E) error {

	return hook.Callback(ctx, tx, baton, state, event)
}

func (hook TransitionHook[K, S, ST, SD, E, IE, SE]) eventType() string {
	return (*new(SE)).PSMEventKey()
}

func (hook TransitionHook[K, S, ST, SD, E, IE, SE]) runOnFollow() bool {
	return hook.RunOnFollow
}

// GeneralLogicHook runs once per transition at the state-machine level
// regardless of which transition / event is being processed. It runs exactly
// once per transition, with the state object in the final state after the
// transition but prior to processing any further events. Chained events are
// added to the *end* of the event queue for the transaction, and side effects
// are published (as always) when the transaction is committed. The function
// MUST be pure, i.e. It MUST NOT produce any side-effects outside of the
// HookBaton, and MUST NOT modify the
// state.
type GeneralLogicHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
] func(context.Context, HookBaton[K, S, ST, SD, E, IE], S, E) error

func (f GeneralLogicHook[K, S, ST, SD, E, IE]) runTransition(ctx context.Context, tx sqrlx.Transaction, baton HookBaton[K, S, ST, SD, E, IE], state S, event E) error {
	return f(ctx, baton, state, event)
}

func (f GeneralLogicHook[K, S, ST, SD, E, IE]) runOnFollow() bool {
	return false
}

// GeneralStateDataHook runs at the state-machine level regardless of which
// transition / event is being processed. It runs at-least once before
// committing a database transaction after multiple transitions are complete.
// This hook has access only to the final state after the transitions and is
// used to update other tables based on the resulting state. It MUST be
// idempotent, it may be called after injecting externally-held state data.
type GeneralStateDataHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
] func(context.Context, sqrlx.Transaction, S) error

func (f GeneralStateDataHook[K, S, ST, SD, E, IE]) runTransition(ctx context.Context, tx sqrlx.Transaction, baton HookBaton[K, S, ST, SD, E, IE], state S) error {
	return f(ctx, tx, state)
}

func (f GeneralStateDataHook[K, S, ST, SD, E, IE]) runOnFollow() bool {
	return true
}

// GeneralEventDataHook runs after each transition at the state-machine level regardless of which
// transition / event is being processed. It runs exactly once per transition,
// before any other events are processed. The presence of this hook type
// prevents (future) transaction optimizations, so should be used sparingly.
type GeneralEventDataHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
] func(context.Context, sqrlx.Transaction, S, E) error

func (f GeneralEventDataHook[K, S, ST, SD, E, IE]) runTransition(ctx context.Context, tx sqrlx.Transaction, baton HookBaton[K, S, ST, SD, E, IE], state S, event E) error {
	return f(ctx, tx, state, event)
}

func (f GeneralEventDataHook[K, S, ST, SD, E, IE]) runOnFollow() bool {
	return true
}

// EventPublishHook runs for each transition, at least once before committing a
// database transaction after multiple transitions are complete. It should
// publish a derived version of the event using the publisher.
type EventPublishHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
] func(context.Context, Publisher, S, E) error

// UpsertPublishHook runs at least once after a set of transitions for an
// entity, it should be used to publish an 'upsert' message of the current
// state. The last call to for a set of transitions will be the final state. Use
// the state metadata's last modified for upsert time.
type UpsertPublishHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
] func(context.Context, Publisher, S) error

func RunLinkHook[
	K IKeyset,
	S IState[K, ST, SD],
	ST IStatusEnum,
	SD IStateData,
	E IEvent[K, S, ST, SD, IE],
	IE IInnerEvent,
	SE IInnerEvent,

	DK IKeyset,
	DIE IInnerEvent,
](
	ctx context.Context,
	destination LinkDestination[DK, DIE],
	callback func(context.Context, S, SE, func(DK, DIE)) error,
	tx sqrlx.Transaction,
	state S,
	event E,
) error {
	asType, ok := any(event.UnwrapPSMEvent()).(SE)
	if !ok {
		return fmt.Errorf("unexpected event type in transition: %T [IE] does not match [SE] (%T)", any(event), new(SE))
	}

	type matchedEvent struct {
		Key   DK
		Inner DIE
	}

	events := make([]matchedEvent, 0, 1)
	err := callback(ctx, state, asType, func(key DK, event DIE) {
		events = append(events, matchedEvent{Key: key, Inner: event})
	})
	if err != nil {
		return err
	}

	cause := &psm_j5pb.Cause{
		Type: &psm_j5pb.Cause_PsmEvent{
			PsmEvent: &psm_j5pb.PSMEventCause{
				EventId:      event.PSMMetadata().EventId,
				StateMachine: (*new(K)).PSMFullName(),
			},
		},
	}

	for _, chained := range events {
		destKeys := chained.Key
		destEvent := chained.Inner
		if err := destination.transitionFromLink(ctx, tx, cause, destKeys, destEvent); err != nil {
			return err
		}
	}
	return nil
}

type LinkDestination[
	DK IKeyset,
	DIE IInnerEvent,
] interface {
	transitionFromLink(
		ctx context.Context,
		tx sqrlx.Transaction,
		cause *psm_j5pb.Cause,
		destKeys DK,
		destEvent DIE,
	) error
}
